<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Глава3 Массивы</title>
</head>
<body>
<script>
var dinosaurs = ["Тираннозавр", "Велоцираптор", "Стегозавр", 
"Трицератопс", "Брахиозавр", "Птеранодон", "Апатозавр", 
"Диплодок", "Компсогнат"];
/* Используя индекс в квадратных скобках, можно задавать или изме-
нять значения элементов и даже добавлять новые элементы. Например,
чтобы заменить содержимое первого элемента массива dinosaurs
("Тираннозавр") на "Тираннозавр рекс", можно написать: */
dinosaurs[0] = "Тираннозавр рекс";
/* С помощью индексов также можно добавлять в массив элементы.
Например, вот как создать массив dinosaurs, задавая каждый элемент
через квадратные скобки: */
var dinosaurs = [];
dinosaurs[0] = "Тираннозавр";
dinosaurs[1] = "Велоцираптор";
dinosaurs[2] = "Стегозавр";
dinosaurs[3] = "Трицератопс";
dinosaurs[4] = "Брахиозавр";
dinosaurs[5] = "Птеранодон";
dinosaurs[6] = "Апатозавр";
dinosaurs[7] = "Диплодок";
dinosaurs[8] = "Компсогнат";
/* разные типы данных в одном массиве */
/* Не обязательно, чтобы элементы массива были одного типа. Например вот массив, в котором хранится число (3), строка ("динозавры"), 
массив (["трицератопс","стегозавр", 3627.6]) и еще одно число (10): */
var dinosaursAndNumbers =[3,"динозавры", ["трицератопс", "стегозавр", 3627.5], 10];
/* чтобы обратится к эллементам массива, вложенного в другой массив, нужно использовать вторую пару квадратных скобок. Например, если команда
dinosaursAndNumbers[2]; вернет весь вложенный массив, то dinosaursAndNumbers[2][0]; - лишь первый элемент этого вложеннного массива 
("трицератопс"). */
dinosaursAndNumbers[2][0];
/* Вводя dinosaursAndNumbers[2][0]; мы просим Javascript обратиться к индексу 2 массива dinosaursAndNumbers, где находится массив 
["трицератопс", "стегозавр", 3627.5], и вернуть значение с индексом 0 из этого вложенного массива - это первый элемент, 
"трицератопс". */
    /* Длина Массива */
/* Порой нужно знать, сколько в массиве элементов. Например, если снова и снова добавлять динозавров в массив dinousaurs, вы можете забыть
сколько их теперь всего.
    Для этого есть свойство length (длина), хранящее количество элементов в массиве. Чтобы узнать длину массива, просто добавьте 
.length после его имени. Давайте посмотрим, как это работает. Но сначала создадим новый массив с тремя элементами: */
var maniacs = ["Якко", "Вакко", "Дот"];
maniacs[0];
"Якко"
maniacs[1];
"Вакко"
maniacs[2];
"Дот"
/* ----------------------
чтобы узнать длину этого массива, добавим .length к maniacs:
---------------------- */
maniacs.length;
/* -------------------------
JavaScript сообщает, что в массиве 3 элемента, и мы знаем, что их индексы - 0,1 и 2. Отсюда следует полезное наблюдение:
последний индекс массива всегда на еденицу меньше длины этого массива. Это значит, что есть простой способ получить последний
элемент массива, какой бы ни была его длина:
-------------------------- */
maniacs[maniacs.length - 1];
/* Мы попросили JavaScript вернуть элемент из нашего массива, но вместо числового индекса ввели в квадратных скобках выражение: длина
массива минус 1. JavaScript нашел свойство maniacs.length со значением 3, Вычел 1, получив 2, и наконец вернул элемент с индексом 2
- это и есть последний элемент, "Дот". */
                /* Добавление элементов в массив */
/* Чтобы добавить элемент к концу массива, можно воспользоваться методом push. Введите .push после имени массива, а после в круглых 
скобках укажите элемент, который нужно добавить: */
var animals = [];
animals.push("Кот");
animals.push("Пес");
animals.push("Лама");
animals;
["Кот", "Пес", "Лама"]
animals.length;
/* командой var animals =[]; мы создали пустой массив animals, а затем методом push добавили туда элемент "Кот". Потом снова 
использовали push, добавив "Пес", а затем "Лама". Запросив теперь содержимое массива animals, мы видим, что "Кот","Пес" и "Лама"
стоят там в том же порядке, в каком мы их добавляли.
    Запуск метода в программировании называется вызовом метода. При вызове метода push происходят две вещи. Во-первых, в массив
добавляется элемент, указанный в скобках. Во-вторых, метод задает новую длину массива. Именно эти значения длины появляются
в консоли после каждого вызова push.
    Чтобы добавить элемент в начало массива, используйте метод .unshift(элементы): */
animals.unshift("Мартышка");
animals.unshift("Белый Медведь");
/* Мы начали с массива, созданного раньше, - ["Кот", "Пес", "Лама"]. Затем добавили в его начало элементы "Мартышка" и "Белый медведь",
отчего остальные элементы сдвинулись вперед - при каждом добавлении их индексы увеличивались на 1. В результате элемент "Кот", у которого
раньше был индекс 0, оказался под индексом 2.
    Как и push, метод unshift при каждом вызове задает новую длину массива. */
                                                /* Удаление элементов массива */
/* Убрать из массива последний элемент можно, добавив к его имени .pop(). Метод pop делает сразу два дела: удаляет последний элемент
из массива и возвращает этот элемент в виде значения. Для примера начнем с нашего массива animals ["Белый медведь", "Мартышка",
"Кот", "Пес", "Лама"]. Далее создадим новую переменную LastAnimal и сохраним в ней последний элемент, вызвав animals.pop(). */

var animals = ["Белый медведь", "Мартышка", "Кот", "Пес", "Лама"]
var lastAnimal = animals.pop();
animals;
["Белый медведь", "Мартышка", "Кот", "Пес", "Лама"]
 /* 1 */  var lastAnimal = animals.pop();
lastAnimal;
"Лама"
animals;
["Белый медведь", "Мартышка", "Кот", "Пес"]
/* 2 */ animals.pop();
"Пес"
animals;
["Белый медведь", "Мартышка", "Кот"]
/* 3 */ animals.unshift(lastAnimal);
animals;
["Лама", "Белый медведь", "Мартышка", "Кот"]

/* При вызове animals.pop() в строке 1 последний элемент массива animals, "Лама", был возвращен и сохранен в переменной LastAnimal.
    Кроме того, элемент "Лама" был удален из массива, в котором после этого осталось четыре элемента. При следующем вызове animals.pop()
    в строке 2 был удален из массива и возвращен элемент "Пес", а элементов в массиве всего три.
Вызвав animals.pop() для элемента "Пес", мы не сохранили это значение в переменной, и оно пропало. С другой стороны, элемент "Лама"
был сохранен в переменной lastAnimal, чтобы при случае им можно было снова воспользоваться. В строке 3 мы с помощью unshift(lastAnimal)
добавили "Лама" обратно, в начало массива. В итоге получился массив ["Лама", "Белый медведь", "Мартышка", "Кот"].
    Методы push и pop хорошо друг друга дополняют, поскольку порой нужно работать только с концом массива. Вы можете добавить элемент 
в конец вызовом push, а потом, когда это понадобится, забрать его оттуда вызово pop. Мы рассмотрим это на примере чуть позже в этой главе.
 */
/* Чтобы удалить из массива первый элемент, вернув его значение, используйте .shift(): */
animals;
["Лама", "Белый медведь", "Мартышка", "Кот"]
var firstAnimal = animals.shift();
firstAnimal;
"Лама"
animals;
["Белый медведь","Мартышка","Кот"]

/* Метод animals.shift() работает аналогично animals.pop(), но элемент берется из начала массива. В начале этого примера массив 
animals имел вид ["Лама", "Белый медведь", "Мартышка", "Кот"].
Вызов .shift() вернул первый элемент, "Лама", который мы сохранили в переменной firstAnimal. Поскольку .shift() не только возвращает
элемент, но и удаляет его, в массиве animals осталось лишь ["Белый медведь", "Мартышка", "Кот"].
Методы unshift и shift добавляют и удаляют элементы с начала массива - так же как push и pop добавляют элементы с конца. */

                    /* Обьединение массивов  */

/* Чтобы "склеить" два массива, создав таким образом новый массив, используйте команду firstarray.concat(otherArray). Метод concat 
создает массив, в котором элементы из firstArray будут расположены перед элементами из otherArray.
    Пускай у нас есть два списка - список пушистых животных и список чешуйчатых животных - и мы хотим их обьединить. Если поместить
наших пушистых животных в массив furryanimals, а чешуйчатых - в массив scalyAnimals, команда furryAnimals.concat(scalyAnimals)
создаст новый массив, в начале которого будут элементы из первого массива, а в конце - из второго. */
var furryAnimals = ["Альпака","Кольцехвостый лемур", "Йети"];
var scalyAnimals = ["Удав", "Годзилла"];
var featheredAnimals = ["Ара", "Додо"];
var allAnimals = furryAnimals.concat(scalyAnimals, featheredAnimals);
allAnimals;
    /* Мы видим, что пернатые животные из массива featheredAnimals оказались в самом конце
нового массива, поскольку featheredAnimals был указан последним в скобках  
метода concat.
    Метод concat удобен, когда нужно обьединить несколько массивов в один. 
Скажем, пусть у Вас есть список любимых книг и у вашего друга тоже есть свой
список, и вы решили выяснить, можно ли купить все эти книги в магазине по соседству.
Тогда будет проще, если у вас будет не два списка, а один. Просто обьедините ваш
список со списком вашего друга методом concat, и пожалуйста у вас один список 
на двоих! */
            /* Поиск индекса элемента в массиве */
/* Чтобы выяснить, какой у определенного элемента индекс в массиве, используйте 
.indexOF("Элемент"). Создадим массив colors с названиями цветов, а затем получим
индексы элементов "синий" и "зеленый" с помощью команд color.indexOf("синий") и
colors.indexOf("зеленый"). Поскольку "синий" распологается по индексу 2,
colors.indexOf("синий") вернет 2. А "Зеленый" находится по индексу 1,
так, что colorsOf("Зеленый") вернет 1.
 */
    var colors = ["Красный","Зеленый", "синий"];
    colors.indexOf("синий");
/* Метод indexOf похож на квадратные скобки, только здесь все наоборот:
команда colors[2] вернет "синий", а colors.indexOf("синий")
вернет 2 */
colors[2];
/* Хотя элемент "синий" стоит третьим по порядку, его индекс равен 2,
ведь мы всегда считаем с 0. Разумеется, то же относится к "зеленый"
с индексом 1.
    Если элемента, индекс которого вы запрашиваете нет, JavaScript вернет
значение -1. */
    /* Таким образом JavaScript сообщает: "элемент не найден", Так
или иначе возвращая из метода число.
    Если элемент встречается в массиве больше чем один раз,
indexOf вернет индекс того элемента, который находится ближе к началу массива. */
var insects = ["Пчела", "Муравей","Пчела", "Пчела", "Муравей"];
insects.indexOf["Пчела"];
/* Превращаем массив в строку  */
/* Воспользовавшись методом .join(), можно соединить все элементы массива в одну
большую строку. */
var boringAnimals = ["Мартышка", "Кот", "Рыба", "Ящерица"];
boringAnimals.join();
"Мартышка, Кот, Рыба, Ящерица"
/* Метод join возвращает строку, в которой через запятую 
перечислены все элементы массива boringAnimals. Но что
если мы не хотим использовать в качестве разделителя запятую?
    Нам поможет метод .join ("разделитель"), который делает все
то же самое, но вместо запятых ставит между элементами
выбранный разделитель. Давайте попробуем три разных разделителя:
дефис с пробелами по сторонам, звездочку * и союз "и" с
пробелами по сторонам. Обратите внимание: разделитель
нужно записывать в кавычках - ведь это строчка. */
/* var boringAnimals = ["Мартышка", "Кот", "Рыба", "Ящерица"];
Этот вариант join удобен, когда у вас есть массив,
из которого нужно сделать строку. Предположим, у вас
много средних имен и вы решили хранить их все в массиве
вместе со своим личным именем и фамилией. 
И вдруг кому-то понадобилось ваше полное имя в виде строки.
Тогда метод join с разделителем-пробелом преобразует все
имена в искому строку: */
var myNames = ["Николас", "Эндрю", "Максвелл", "Морган"];
myNames.join(" ")
/* не будь метода join, пришлось бы соединять элементы вручную,
это очень утомительно: */
myNames[0] + "" + myNames[1] + "" + myNames[2] + "" + myNames[3];
/* Кроме того, этот код сработает, только если у вас ровно два
средних имени. Если же их три или одно, программу придется
менять. А с join ничего менять не надо - этот метод
соединит в строку все элементы массива независимо от его длины.
Если же в массиве храняться нестроковые значения, 
Javscript преобразует их в строки перед тем, как соединить. */
var ages = [11,14,79];
ages.join(" ");
    /* Что полезного можно сделать с массивами */
/* Теперь вы умеете разными способами создавать массивы
и знаете немало действий с ними. Но как все это может 
вам пригодится в жизни? В этом разделе мы разберем несколько
коротких программ, посвященных практическому применению
массивов. */
    /* Поиск дороги домой */
/* Представьте, что ваша подруга побывала у вас в гостях,
а теперь хочет показать вам свой дом. Но вот незадача
- вы никогда не бывали у нее дома, а путь предстоит 
проделать вам в одиночку. */
    /* К счастью, вам в голову приходит хитрый способ решения
этой проблемы: по дороге к дому подруги вы будете записывать
возможные ориентиры (телефонную будку, вывеску магазина
или аптеки, школу и т.д.)ю
А по дороге назад, двигаясь по списку с конца, вычеркивать
каждый встреченный ориентир - так вы всегда будете знать,
куда идти дальше. */
 /* Построение массива с помощью push */
/*  Давайте напишем код для выполнения этих действий. Начнем с создания массива
 - пустого, поскольку, пока вы еще не отправились в гости, неизвестно, какие ориентиры 
 вам повстречаются. Затем, по дороге к дому вашей подруги, мы будем добавлять описание каждого 
 ориентира в массив push. И наконец, когда прдет время идти домой, будем методом pop изымать 
 каждый пройденный ориентир из массива.  */
var landmarks = [];
landmarks.push("Мой дом");
landmarks.push("Дорожка к дому");
landmarks.push("Мигающий фонарь");
landmarks.push("Протекающий гидрант");
landmarks.push("Пожарная станция");
landmarks.push("приют для кошек");
landmarks.push("моя бывшая школа");
landmarks.push("Дом подруги");
/* здесь мы создали пустой массив landmarks и методом push сохранили в нем все ориентиры, замеченные по дороге к дому подруги. */
/* Вы добрались до дома подруги, и можно изучить массив ориентиров. Разумеется, первым стоит "Мой дом", потом "Дорожка к дому", и т.д. 
до конца массива, где находится элемент "Дом подруги". Теперь, когда наступит время идти домой, вам останется лишь изымать из массива по 
одному элементу, и всегда будет понятно, куда идти дальше. */
landmarks.pop();
"Дом подруги"
landmarks.pop();
"Моя бывшая школа"
landmarks.pop();
"Приют для кошек"
landmarks.pop();
"Пожарная станция"
landmarks.pop();
"Протекающий гидрант"
landmarks.pop();
"Мигающий фонарь"
landmarks.pop();
"Дорожка к дому"
landmarks.pop();
"Мой дом"
/* Вот вы и дома! 
Заметили, что первый ориентир, который вы поместили в массив методом push, оказался также последним, который вы извлекли методом
pop? А последний добавленный ориентир оказался первым извлеченным? Может показаться, что лучше бы первый добавленный элемент и извлекался
всегда первым, однако извлекать элементы в обратном порядке в некоторых случаях удобно. 
    Такой подход нередко используется в больших программах - именно поэтому push и pop в Javascript всегда под рукой.
!!!!! Среди программистов такой способ работы с элементами называется "стек". Представьте, что стек - это стопка блинов. Всякий
раз, когда готов новый блин, его кладут сверху стопки (как метод push), и, когда вы берете блин, чтобы его съесть, вы тоже берете
его сверху (как метод pop). Снятие элементов со стека похоже на путешествие назад во времени: последним изымается элемент, который был в
стеке первым. То же происходит с блинами: последний блин, чтобы его сьесть, вы тоже берете его сверху (как метод pop). Снятие
элементов со стека похоже на путешествие назад во времени: последним изымается элемент, который был в стеке первым. То же происходит
с блинами: последний блин, который вы сьедите, - это первый, который был приготовлен. На сленге программистов этот способ называется 
"последним вошел, первым вышел", английская абреввиатура LIFO (last in, first out). Есть и альтернативный подход - "первым вошел, первым вышел",
абреввиатура FIFO (first in, first out). Его также называют очередью, поскольку таким же образом устроены очереди - первый человек,
вставший в очередь, будет первым, которого обслужат. */

/* Случайный выбор!! */
/* Используя массивы, можно написать программу, которая выдает случайные варианты из заданного списка (наподобие "шара судьбы").
Однако сначало нужно разобраться, откуда нам брать случайные числа.случайные

Использование Math.random()
Случайные числа можно генерировать с помощью специального метода Math.random(), который при каждом вызове возвращает случайное 
число от 0 до 1:
 */
 Math.random();
0.8945409457664937
Math.random();
0.3697543195448816
Math.random();
0.48314980138093233

/* Важно помнить, что Math.random() всегда возвращает число меньше 1, то есть никогда не возвращает собственно 1.
  Если вам нужно число побольше, просто умножьте полученное из метода Math.random() значение на подходящий коэффициент. Например
если нужно случайное число от 0 до 10, умножьте Math.random() на 10
 */
 Math.random() * 10;
7.648027329705656
Math.random() * 10;
9.7565904534421861
Math.random() * 10;
0.21483442978933454

/* Окгруление с помощью Math.floor()
И все же эти случайные значения нельзя использовать как индексы в массиве, поскольку индексы должны быть целыми числами, а не 
десятичными дробями. Чтобы исправить этот недостаток, нужен метод Math.floor(), округляющий число до ближайшего снизу целого
значения (по сути, он просто отбрасывает все знаки после запятой).
 */
 Math.floor(3.7463463);
3
Math.floor(9.9999);
9
Math.floor(0.793423451963426);
0

/* Давайте используем оба метода, чтобы получить случайный индекс. Нужно лишь умножить Math.random() на длину массива и затем окгрулить
полученное число методом Math.floor(). Например, если в массиве четыре элементам, это можно сделать так.  */

Math.floor(Math.random() * 4);
2 // может выпасть 0, 1, 2 или 3

/* При каждом запуске этот код будет возвращать случайное число от 0 до 3 (включая 0 и 3). Поскольку Math.random() всегда возвращает значение
меньше 1, Math.random() * 4 никогда не вернет 4 или большее число.
    Используя это случайное число как индекс, можно получить случайный элемент массива: */
var randomWords = ["Взрыв", "Пещера", "Принцесса", "Карандаш"];
var randomindex = Math.floor(Math.random()*4);
randomWords[radndomIndex];

/* С помощью Math.floor(Math.random()* 4); Мы получили случайное число от 0 до 3. Сохранив это число в переменной randomIndex, мы 
использовали его как индекс для получения строки из массива randomWords.
    В сущности, можно сделать этот код короче, избавившись от переменной randomIndex: */
randomWords[Math.floor(Math.random() * 4)];
"Принцесса"

/* Программа случайного выбора вариантов 
Теперь давайте создадим массив с фразами, чтобы случайным образом выбирать их с помощью написанного ранее кода. Это и будет наш
компьютерный "шар судьбы"! В комментариях указаны примеры вопросов, которые можно задать нашей программе. */
var phrases = [
"Звучит неплохо",
"Да, это определенно надо сделать",
"Не думаю, что это хорошая идея",
"Может, не сегодня?",
"Компьютер говорит нет"
];
// Мне выпить еще молочного коктейля?
3. Массивы 67
phrases[Math.floor(Math.random() * 5)];
"Не думаю, что это хорошая идея"
// Мне пора делать домашнюю работу?
phrases[Math.floor(Math.random() * 5)];
"Может, не сегодня?”

/* Мы создали массив phrases, в котором хранятся различные советы. Теперь, придумав вопрос, можно запросить случайный элемент
из массива phrases, и полученный совет поможет принять рещение!
    Обратите внимание: поскольку в массиве с советами пять элементов, мы умножаем Math.random() на 5. Таким образом, 
мы всегда получим одно из пяти значений индекса: 0, 1, 2, 3 или 4. */

/* Генератор случайных дразнилок 

Можно усовершенствовать код выбора вариантов, создав программу, которая при каждом запуске генерирует случайную дразнилку! */

var randomBodyParts = ["глаз", "нос","череп"];
var randomAdjectives = ["вонючая", "унылая", "дурацкая"];
var randomWords = ["муха", "выдра", "дубина", "мартышка", "крыса"];
// Выбор случайной части тела из массива randomBodyParts:
var randomBodyPart = randomBodyParts[Math.floor(Math.random()*3)];
// Выбор случайного прилагательного из массива randomAdjectives:
var randomAdjective = randomAdjectives[Math.floor(Math.random()* 3)];
// Выбор случайного слова из массива randomWords:
var randomWord = randomWords[Math.floor(Math.random() *5)];
// Соединяем случайные строки в предложение:
var randomInsult = "У тебя" + randomBodyPart + "словно" + randomAdjective + " " + randomWord + "!!!";
randomInsult;
"У тебя нос словно дурацкая выдра!!!"

/* У нас есть три массива со словами, и в строках 1, 2 и 3 мы с помощью трех индексов берем из каждого массива по случайному слову.
Затем мы склеиваем их, помещая результат в переменную randomInsult, - это и есть готовая дразнилка. В строках 1 и 2 мы используем
множитель 3, поскольку и в randomAdjective, и в randomBodyPart по три элемента. Аналогично в строке 3 мы умножаем на 5, ведь в 
randomWords пять элементов. Обратите внимание, что мы добавили между randomAdjective и randomWord строку с единственным пробелом.
Запустите этот код несколько раз - при каждом запуске получится новая случаная дразнилка! */

/* !!!! Если хотите все сделать по-умному, замените строку на вот такую: !!!! */

var randomBodyParts = ["глаз", "нос","череп"];
var randomAdjectives = ["вонючая", "унылая", "дурацкая"];
var randomWord = randomWords[Math.floor(Math.random() * randomWords.length)];
// Выбор случайной части тела из массива randomBodyParts:
var randomBodyPart = randomBodyParts[Math.floor(Math.random()*3)];
// Выбор случайного прилагательного из массива randomAdjectives:
var randomAdjective = randomAdjectives[Math.floor(Math.random()* 3)];
// Выбор случайного слова из массива randomWords:
var randomWord = randomWords[Math.floor(Math.random() *5)];
// Соединяем случайные строки в предложение:
var randomInsult = "У тебя" + randomBodyPart + "словно" + randomAdjective + " " + randomWord + "!!!";
randomInsult;

/* В этой программе всегда надо умножать Math.random() на длину массива; использование randomWords.length как множителя означает, 
что нам не понадобится менять этот код, если длина массива изменится. */

/* Вот еще один способ составления случайной дразнилки: */

var randomInsult = ["У тебя", randomBodypart, "словно", randomAdjective, randomWord + "!!!"].join("");

/* В этом варианте каждое слово дразнилки - это отдельный элемент массива, и мы соединяем все эти элементы меотодом join с
разделителем-пробелом. Лишь в одном случае пробел не нужен - между randomWord и "!!!". В этом случае мы используем оператор +,
чтобы соединить строки без проблема. */








</script>
</body>
</html>