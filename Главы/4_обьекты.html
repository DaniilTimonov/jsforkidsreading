<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Глава4 обьекты</title>
</head>
<body>
<script>

/* Обьекты JavaScript очень похожи на массивы, но для доступа к элементам обьектов используются строки, а не числа. Эти строки называют
ключами, или свойствами, а элементы, которые им соотвествуют, - значениями. Вместе эти фрагменты информации образуют пары
"ключ значение". Причем если массивы используются главным образом как списки, хранящие множество элементов, то обьекты часто применяют
как одиночные сущности с множеством характеристик, или атрибутов. Например, в третьей главе мы создали несколько массивов, хранящих
названия разных животных. Но что если нужно хранить набор различных сведений об одном конкретном животном?
    Создание обьектов.
Для хранения всевозможной информации об одном животном подойдет JavaScript-обьект. Вот пример обьекта, где хранятся сведения о трехногой
кошке по имени Гармония. */
    var cat = {
        "legs": 3;
        "name": "Гармония",
        "color": "Черепаховый"
    };
/* Мы создали переменную под названием cat и присвоили ей обьект с тремя парами "ключ-значение" (лапы, имя, окрас). При создании обьекта
используются фигурные скобки {} вместо квадратных, к которым мы привыкли, создавая массивы. Внутри фигурных скобок можно вводить пары
"ключ-значение", а вместе скобки и пары значений называются литералом обьекта. Литерал обьекта - это быстрый способ создания
обьекта вместе с его содержимым.  */

/* !!! Мы уже встречались с литералами массивов (например, ["a", "б", "в"]), числовыми литералами (например 37), строковыми литералами 
(например, "лось") и булевыми литералами (true и false). Литерал - это когда значение записывается сразу и целиком, а 
не составляется постепенно, шаг за шагом.
    Например, чтобы создать массив с числами от 1 до 3, можно ввести литерал массива [1,2,3]. Альтернативный способ - создать пустой
массив и методом push добавить в него значения 1,2 и 3. Не всегда заранее известно, что за данные будут хранится в массиве или обьекте,
поэтому создавать массивы и обьекты с помощью одних лишь литералов не получится. */
    /* Ключи без кавычек */
/* Создавая первый обьект, мы писали имена ключей в кавычках, однако это не обязательно. Следующая запись тоже является допустимым
литералом обьекта: */
    var cat = {
        legs:3,
        name:"Гармония",
        color:"Черепаховый"
    };
/* JavaScript знает, что ключи всегда строковые, поэтому можно обходиться без кавычек. В этом случае имена ключей должны соответствовать 
тем же правилам, что и имена переменных: например, в них не должно быть пробелов. Но если ключ указан в кавычках, пробелы в его 
имени допустимы. */
    var cat = {
        legs:3;
        "full name": "Гармония Филомена Уси-Пусечка Морган";
        color:"Черепаховый";
    };
/* Помните, что, хотя ключ всегда является строковым (в кавычках он записан или без), значение, соответсвующее этому ключу, может быть
любого типа - даже переменной, в которой хранятся данные.
    Кроме того, весь обьект можно записать одной строкой, хотя читать такую программу будет, пожалуй, не слишком удобно: */
    var cat = {legs:3, name:"Гармония", color:"Черепаховый"};
/* Доступ к значениям внутри обьектов */
    /* Хранящиеся в обьектах значения можно получить с помощью квадратных скобок - так же, как элементы массива. Единственное различие
в том, что вместо индекса (число) испольуется ключ (строка). */
var cat = {legs:3, name:"Гармония", color:"Черепаховый"};
cat["name"];
"Гармония"
    /* Точно так же, необязательны кавычки при записи литерала обьекта, их можно опускать и при доступе к значеиям по ключу. 
    Однако в этом случае код будет немного другим: */
    var cat = {legs:3, name:"Гармония", color:"Черепаховый"};
    cat.name
    "Гармония"
/* Такую запись называют точечной нотацией. Вместо того чтобы писать имя ключа в кавычках внутри квадратных скобок, мы просто 
ставим точку, после которой пишем имя ключа, без кавычек. И, аналогично ключам без кавычек при записи литерала, такой прием сработает, 
только если ключ не содержит специальных символов - например, пробелов. 
    Теперь предположим, что вы хотите узнать, какие вообще ключи есть у данного обьекта. Для этого в JavaScript есть удобное средство - 
команда Object.keys(): */
    var dog = { name:"Оладушек", age: 6, color:"белый", bark:"Гаф тяф тяф!"};
    var cat = {name:"Гармония", age:8, color:"Черепаховый"};
/* Object.keys(anyObject) возвращает массив, содержащий все ключи обьекта anyObject */
    /* Добавление элементов обьекта */
/* Пусто обьект похож на пустой массив, только вместо квадратных скобок при его создании используются фигурные: */
var object = {};
/* Добавлять элементы обьекта можно так же, как элементы массива, - но используя строки вместо чисел: */
var cat = {};
cat["legs"] = 3;
cat["name"] = "Гармония";
cat["color"] = "Черепаховый";
cat;
/* мы начали с пустого обьекта под названием cat, а затем поочередно добавили к нему три пары "ключ-значение". Потом мы ввели cat;
и браузер отобразил содержимое обьекта. Тут надо отметить, что разные браузеры могут показывать обьекты по-разному. Например, 
Chrome (на момент написания этих строк) выводит обьект cat в консоли следующим образом: */
    /* Chrome перечисляет ключи в таком порядке - (legs, name, color), но другие браузеры могут выводить их в другой очередности.
Дело в том, что JavaScript хранит ключи обьектов, не упорядочивая их.
    В массивах элементы расположены строго один за другим: индекс 0 перед индексом 1, индекс 3 после индекса 2; однако в случае обьектов
неясно, как расположить элементы друг относительно друга. Должен ли ключ color стоять перед legs или после? "Правильного" ответа на этот
вопрос нет, поэтому обьекты хранят свои ключи без конкретной очередности, в результате чего разные браузеры показывают ключи в разном
порядке. Так что никогда не пологайтесь в своих программах на тот или иной порядок ключей. */
    /* Добавление ключей через точку 
Новые ключи также можно добавлять через точечную нотацию. Давайте перепишем этим способом предыдущий пример, то есть создадим пустой
обьект и заполним его данными: */    
    var cat = {};
    cat.legs =3;
    cat.name = "Гармония";
    cat.color= "Черепаховый";
/* Если обратиться к несуществующему свойству обьекта, JavaScript вернет специальное значение undefined, сообщая таким образом:
"Здесь ничего нет". Например: */
    var dog = {
        name:"Оладушек",
        legs:4,
        isAwesome: true
    };
    dog.isBrown

/* Здесь мы определили три свойства обьекта dog: name, legs и isAwesome. Свойства isBrown среди них нет, поэтому dog.isBrown
возвращает undefined. */
  /*   Массивы обьектов 
До этого момента мы рассматривали только массивы и обьекты, в которых содержатся данные простых типов, такие как числа и строки.
Однако ничто не мешает сделать элементом массива или обьекта другой массив или обьект. Например, так может выглядеть массив
с обьектами, описывающими динозавров: */
        var dinosaurs = [
            { name:"Тиранозавр рекс", period: "Верхнемеловой" },
            { name:"Стегозавр", period:"Верхнеюрский" },
            { name:"Платеозавр", period:"Триасовый" }
        ];
/* Получить сведения о первом динозавре можно уже известным нам способом - указав индекс в квадратных скобках: */
        dinosaurs[0];
/* А если нужно только название первого динозавра, достаточно указать ключ обьекта в еще одних квадратных скобках, следом за индексом: */
        dinosaurs[0]["name"];
/* Другой вариант - воспользоваться точечной нотацией: */
dinosaurs[1].period;
    /* ! Точечную нотацию можно использовать только с обьектами, для массивов она не подходит ! */
                    /* Массив друзей */
/* Давайте рассмотрим более сложный пример - массив обьектов со сведениями о друзьях, где в каждый из обьектов вложено по еще одному
массиву. Сначала создадим обьекты, а затем поместим их в массив. */
            var anna = {name: "Анна", age:11, Luckynumbers:[2,4,8,16]};
            var dave = {name:"Дэйв", age:5, Luckynumbers:[3,9,40]};
            var kate = {name:"Кэйт", age:9, Luckynumbers:[1,2,3]};
/* Мы создали три обьекта, сохранив их в переменных anna, dave и kate. У каждого из этих обьектов есть по три свойства: name, age 
и Luckynumbers. Каждому ключу name соответствует строковое значение, ключу age - числовое, а ключу Luckynumbers - массив,
содержащий несколько чисел.
    теперь создадим массив друзей: */
var friends = [anna, dave, kate];
    /* Итак, в переменной friends находится массив с тремя элементами:
anna, dave и kate (каждый из них является обьектом). Мы можем получить любой из обьектов по его индексу в массиве: */
friends[1];
    {name:"Дэйв", age:5, luckyNumbers: Array[3] }
/* Здесь мы извлекли из массива второй обьект, dave (по индексу 1).
Вместо массива Luckynumbers Chrome напечатал Array[3], что означает "это массив с тремя элементами" (можно изучить содержимое этого
массива с помощью Chrome, см. раздел "Исследование обьектов в консоли" на с. 77). Также мы можем получить значение, хранящееся
в обьекте, указав индекс обьекта в квадратных скобках, поставив точку и написав соответсвующий ключ: */
friends[2].name
    /* Этот код запрашивает элемент по индексу 2 (что соответствует переменной kate), а затем - свойство этого обьекта, хранящееся
по ключу "name" (это "Кейт"). Можно даже получить значение из массива, находящегося в обьекте, который, в свою очередь,
находится в массиве friends: */
    friends[0].luckyNumbers[1];
/* Использованные в этом примере индексы показаны на рис. 4.2. friends[0] - это элемент по индексу 0 из массива friends, то есть 
обьект anna.friends[0].luckyNumbers - это массив [2,4,8,16] из обьекта anna. И наконец, friends[0].luckyNumbers[1] - это 
значение по индексу 1 из массива luckyNumbers - то есть число 4. */ 
    /* исследование обьектов в консоли */
/* Chrome позволяет изучать содержимое обьектов, показанных в консоли. Например, если вы введете. */
friends[1];
/* Не беспокойтесь о свойствах с названием _proto_, они относятся к прототипу обьекта. Мы поговорим о прототипах позже, в главе 12.
Обратите внимание, что помимо элементов массива интерпретатор показывает его свойство length.
    Также вы можете посмотреть массив friends целиком и раскрыть каждый его элемент, как показано на рис. 4.6. */
/* Что полезного можно сделать с обьектами */
/* Теперь, когда вам известны разные способы создания обьектов и добавления к ним свойств, давайте применим эти знания на практике,
введя несколько простых программ. */
    /* Учет долгов */
/* Предположим, вы решили открыть банк. Вы одолжили друзьям денег и теперь думаете, как вести учет того, кто и сколько вам должен.
    Можно использовать обьект как способ связать строку с числом. 
Строкой в нашем случае будет имя друга, а числом - сумма, которую вам должны: */
/* 1 */  var owedMoney = {};
/* 2 */  owedMoney["Джимми"] = 5;
/* 3 */  owedMoney["Анна"] = 7;
/* 4 */  owedMoney["Джимми"];
/* 5 */  owedMoney["Элис"];
    /* В строке 1 мы создали пустой массив owedMoney.
    В строке 2 мы присвоили ключу "Джимми" значение 5,
    а в строке 3 присвоили значение 7 ключу "Анна".
    В строке 4, запросив значение, связанное с ключом "Джимми",
    мы получили 5. Затем в строке 5, пытаясь узнать значение, связанное
    с ключом "Элис", мы получили ответ undefined, поскольку такой ключ не задан.
        Теперь представим, что Джимми занял у вас еще немного денег (скажем, 3 доллара). Пора обновить данные
        в нашем обьекте, добавив 3 к долгу Джимми - используем для этого оператор "плюс равно" (+=), речь о котором
        шла во второй главе. */
owedMoney["Джимми"] += 3;
owedMoney["Джимми"] /* - выдаст 8 */
    /* Это примерно то же самое, что и owedMoney["Джимми"] = owedMoney["Джимми"] + 3. Также можно посмотреть на обьект целиком,
    чтобы выяснить, сколько денег задолжал каждый из друзей. */
    owedMoney;
/* { Джимми: 8, Анна: 7 } */
        /* Хранение информации о фильмах */
/* Предположим, у вас большая коллекция кино на DVD и Bluray. Правда было бы здорово хранить информацию об этих фильмах на компьютере, чтобы
в случае чего быстро найти сведения о том или ином фильме?
    Для этого можно создать обьект, каждый ключ в котором - это название фильма, а каждое значение - другой обьект, в котором содержится 
информация об этом фильме. Да хранящиеся в обьекте значения тоже могут быть обьектами! */
var movies = {
    "В поисках Немо": {
        releaseDate: 2003,
        duration: 100,
        actors: ["Альберт Брукс", "Эллен Дедженерс", "Александр Гоулд"],
        format: "DVD"
    },
    "Звездные войны: Эпизод VI - Возвращение джедая": {
        releaseDate: 1983,
        duration:157,
        actors: ["Дэниел Рэдклиф", "Эмма Уотсон", "Руперт Гринт"],
        format:"Blu-ray"
    },
    "Гарри Поттер и Кубок огня": {
        releaseDate: 2005,
        duration:157,
        actors: ["Дэниел Рэдклиф", "Эмма Уотсон", "Руперт Гринт"],
        format: "Blu-ray"
    }
};
 /*    Наверное, вы заметили, что названия фильмов (ключи внешнего обьекта) я поставил в кавычки, но ключи внутренних обьектов записал
    без кавычек. Дело в том, что в названиях нужны пробелы - иначе пришлось бы писать нечто вроде ЗвездныеВойныЭпизодVIВозвращениеДжедая,
    а это уж совсем нелепо. Для ключей вложенных обьектов кавычки необязательны, поэтому я их и не ставил. Код выглядит аккуратнее, когда
    в нем нет излишних знаков пунктуации.
        Теперь, если вы захотите что-то узнать о фильме, это легко сделать: */
var findingNemo = movies["В поисках Немо"];
findingNemo.duration;
/* 100 */
findingNemo.format;
/* "DVD" */
        /* Мы сохранили сведения и фильме "В поисках Немо" в переменной findingNemo. Теперь достаточно обратится к свойствам этого обьекта
(таким как duration и format), чтобы получить интересующую нас информацию. 
    Кроме того, в коллекцию легко добавить новые фильмы: */
var cars = {
    releaseDate = 2006,
    duration: 117,
    actors: ["Оуэн Уилсон", "Бони Хант", "Пол Ньюман"],
    format:"Blu-ray"
};
movies["Тачки"] = cars;
    /*     Что мы узнали?
Теперь мы знаем, как устроены обьекты JavaScript. Они во многом похожи на массивы и тоже нужны для хранения множества элементов
данных в одном месте. Но есть важное отличие - для доступа к элементам обьекта используются строки, тогда как элементы массива
расположены по числовым индексам. Поэтому массивы отсортрированы по порядку, а обьекты нет.
    В дальнейших главах, когда мы больше узнаем о возможностях JavaScript, мы научимся использовать обьекты для многих других задач.
В следующей главе речь пойдет об HTML - языке разметки веб-страниц. */

 
            /* мой пример */
var terranUnits = {
    "terran marine": {
        armor:1,
        damage:8,
        hitpoints:50,
        kills: 0,
        speech: function() {
    return "go go go ";
  }
    }

};
var terranMarine = terranUnits["terran marine"];
terranMarine.speech;




</script>
</body>
</html>